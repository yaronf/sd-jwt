-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Selective Disclosure for JSON Web Tokens (RFC 9901)
--   
--   Implementation of RFC 9901: Selective Disclosure for JSON Web Tokens
--   (SD-JWT)
@package sd-jwt
@version 0.1.0.1


-- | Core data types for SD-JWT (Selective Disclosure for JSON Web Tokens).
--   
--   This module defines all the data types used throughout the SD-JWT
--   library, including hash algorithms, disclosures, SD-JWT structures,
--   and error types. These types correspond to the structures defined in
--   RFC 9901.
module SDJWT.Internal.Types

-- | Hash algorithm identifier for computing disclosure digests.
--   
--   All three algorithms (SHA-256, SHA-384, SHA-512) must be supported.
--   SHA-256 is the default when _sd_alg is not specified in the SD-JWT.
data HashAlgorithm

-- | SHA-256 (default, required)
SHA256 :: HashAlgorithm

-- | SHA-384
SHA384 :: HashAlgorithm

-- | SHA-512
SHA512 :: HashAlgorithm

-- | Salt value (cryptographically secure random).
--   
--   Salts are used when creating disclosures to prevent brute-force
--   attacks. RFC 9901 recommends 128 bits (16 bytes) of entropy.
newtype Salt
Salt :: ByteString -> Salt
[unSalt] :: Salt -> ByteString

-- | Digest (base64url-encoded hash).
--   
--   A digest is the base64url-encoded hash of a disclosure. Digests
--   replace claim values in the SD-JWT payload to enable selective
--   disclosure.
newtype Digest
Digest :: Text -> Digest
[unDigest] :: Digest -> Text

-- | Disclosure for object properties: [salt, claim_name, claim_value]
data ObjectDisclosure
ObjectDisclosure :: Salt -> Text -> Value -> ObjectDisclosure
[disclosureSalt] :: ObjectDisclosure -> Salt
[disclosureName] :: ObjectDisclosure -> Text
[disclosureValue] :: ObjectDisclosure -> Value

-- | Disclosure for array elements: [salt, claim_value]
data ArrayDisclosure
ArrayDisclosure :: Salt -> Value -> ArrayDisclosure
[arraySalt] :: ArrayDisclosure -> Salt
[arrayValue] :: ArrayDisclosure -> Value

-- | Unified disclosure type
data Disclosure
DisclosureObject :: ObjectDisclosure -> Disclosure
DisclosureArray :: ArrayDisclosure -> Disclosure

-- | Encoded disclosure (base64url string)
newtype EncodedDisclosure
EncodedDisclosure :: Text -> EncodedDisclosure
[unEncodedDisclosure] :: EncodedDisclosure -> Text

-- | SD-JWT payload structure Note: This is a simplified representation.
--   The actual payload is a JSON object with _sd arrays and ... objects
--   for arrays.
data SDJWTPayload
SDJWTPayload :: Maybe HashAlgorithm -> Value -> SDJWTPayload

-- | _sd_alg claim
[sdAlg] :: SDJWTPayload -> Maybe HashAlgorithm

-- | The actual JSON payload
[payloadValue] :: SDJWTPayload -> Value

-- | Key Binding information from cnf claim
--   
--   The public key is stored as a JWK JSON string (Text), which is
--   compatible with <a>JWKLike</a>. This allows users to work with JWKs
--   without requiring a direct dependency on the jose library.
newtype KeyBindingInfo
KeyBindingInfo :: Text -> KeyBindingInfo

-- | Holder's public key from cnf claim (JWK JSON string)
[kbPublicKey] :: KeyBindingInfo -> Text

-- | Complete SD-JWT structure (as issued)
data SDJWT
SDJWT :: Text -> [EncodedDisclosure] -> SDJWT

-- | The signed JWT (compact serialization)
[issuerSignedJWT] :: SDJWT -> Text

-- | All disclosures
[disclosures] :: SDJWT -> [EncodedDisclosure]

-- | SD-JWT presentation (with selected disclosures)
data SDJWTPresentation
SDJWTPresentation :: Text -> [EncodedDisclosure] -> Maybe Text -> SDJWTPresentation
[presentationJWT] :: SDJWTPresentation -> Text
[selectedDisclosures] :: SDJWTPresentation -> [EncodedDisclosure]

-- | KB-JWT if present
[keyBindingJWT] :: SDJWTPresentation -> Maybe Text

-- | Processed SD-JWT payload (after verification)
data ProcessedSDJWTPayload
ProcessedSDJWTPayload :: Object -> Maybe KeyBindingInfo -> ProcessedSDJWTPayload

-- | Processed claims as a JSON object
[processedClaims] :: ProcessedSDJWTPayload -> Object

-- | Key binding information if KB-JWT was present and verified
[keyBindingInfo] :: ProcessedSDJWTPayload -> Maybe KeyBindingInfo

-- | SD-JWT errors
data SDJWTError
InvalidDisclosureFormat :: Text -> SDJWTError
InvalidDigest :: Text -> SDJWTError
MissingDisclosure :: Text -> SDJWTError
DuplicateDisclosure :: Text -> SDJWTError
InvalidSignature :: Text -> SDJWTError
InvalidKeyBinding :: Text -> SDJWTError
InvalidHashAlgorithm :: Text -> SDJWTError
InvalidClaimName :: Text -> SDJWTError
SaltGenerationError :: Text -> SDJWTError
JSONParseError :: Text -> SDJWTError
SerializationError :: Text -> SDJWTError
VerificationError :: Text -> SDJWTError
instance GHC.Generics.Generic SDJWT.Internal.Types.HashAlgorithm
instance GHC.Read.Read SDJWT.Internal.Types.HashAlgorithm
instance GHC.Show.Show SDJWT.Internal.Types.HashAlgorithm
instance GHC.Classes.Eq SDJWT.Internal.Types.HashAlgorithm
instance GHC.Generics.Generic SDJWT.Internal.Types.Salt
instance GHC.Show.Show SDJWT.Internal.Types.Salt
instance GHC.Classes.Eq SDJWT.Internal.Types.Salt
instance GHC.Generics.Generic SDJWT.Internal.Types.Digest
instance GHC.Show.Show SDJWT.Internal.Types.Digest
instance GHC.Classes.Eq SDJWT.Internal.Types.Digest
instance GHC.Generics.Generic SDJWT.Internal.Types.ObjectDisclosure
instance GHC.Show.Show SDJWT.Internal.Types.ObjectDisclosure
instance GHC.Classes.Eq SDJWT.Internal.Types.ObjectDisclosure
instance GHC.Generics.Generic SDJWT.Internal.Types.ArrayDisclosure
instance GHC.Show.Show SDJWT.Internal.Types.ArrayDisclosure
instance GHC.Classes.Eq SDJWT.Internal.Types.ArrayDisclosure
instance GHC.Generics.Generic SDJWT.Internal.Types.Disclosure
instance GHC.Show.Show SDJWT.Internal.Types.Disclosure
instance GHC.Classes.Eq SDJWT.Internal.Types.Disclosure
instance GHC.Generics.Generic SDJWT.Internal.Types.EncodedDisclosure
instance GHC.Show.Show SDJWT.Internal.Types.EncodedDisclosure
instance GHC.Classes.Eq SDJWT.Internal.Types.EncodedDisclosure
instance GHC.Generics.Generic SDJWT.Internal.Types.KeyBindingInfo
instance GHC.Show.Show SDJWT.Internal.Types.KeyBindingInfo
instance GHC.Classes.Eq SDJWT.Internal.Types.KeyBindingInfo
instance GHC.Generics.Generic SDJWT.Internal.Types.SDJWTPayload
instance GHC.Show.Show SDJWT.Internal.Types.SDJWTPayload
instance GHC.Classes.Eq SDJWT.Internal.Types.SDJWTPayload
instance GHC.Generics.Generic SDJWT.Internal.Types.SDJWT
instance GHC.Show.Show SDJWT.Internal.Types.SDJWT
instance GHC.Classes.Eq SDJWT.Internal.Types.SDJWT
instance GHC.Generics.Generic SDJWT.Internal.Types.SDJWTPresentation
instance GHC.Show.Show SDJWT.Internal.Types.SDJWTPresentation
instance GHC.Classes.Eq SDJWT.Internal.Types.SDJWTPresentation
instance GHC.Generics.Generic SDJWT.Internal.Types.ProcessedSDJWTPayload
instance GHC.Show.Show SDJWT.Internal.Types.ProcessedSDJWTPayload
instance GHC.Classes.Eq SDJWT.Internal.Types.ProcessedSDJWTPayload
instance GHC.Show.Show SDJWT.Internal.Types.SDJWTError
instance GHC.Classes.Eq SDJWT.Internal.Types.SDJWTError


-- | Serialization and deserialization of SD-JWT structures.
--   
--   This module provides functions to serialize and deserialize SD-JWTs
--   to/from the tilde-separated format specified in RFC 9901.
module SDJWT.Internal.Serialization

-- | Serialize SD-JWT to tilde-separated format.
--   
--   Format: <tt><a>JWT</a>~<a>1</a>~<a>2</a>~...~<a>N</a>~</tt>
--   
--   The last tilde is always present, even if there are no disclosures.
serializeSDJWT :: SDJWT -> Text

-- | Deserialize SD-JWT from tilde-separated format.
--   
--   Parses a tilde-separated string into an <a>SDJWT</a> structure.
--   Returns an error if the format is invalid or if a Key Binding JWT is
--   present (use <a>deserializePresentation</a> for SD-JWT+KB).
deserializeSDJWT :: Text -> Either SDJWTError SDJWT

-- | Serialize SD-JWT presentation.
--   
--   Format: <tt><a>JWT</a>~<a>1</a>~...~<a>N</a>~[<a>KB-JWT</a>]</tt>
--   
--   If a Key Binding JWT is present, it is included as the last component.
--   Otherwise, the last component is empty (just a trailing tilde).
serializePresentation :: SDJWTPresentation -> Text

-- | Deserialize SD-JWT presentation.
--   
--   Parses a tilde-separated string into an <a>SDJWTPresentation</a>
--   structure. This handles both SD-JWT (without KB-JWT) and SD-JWT+KB
--   (with KB-JWT) formats.
deserializePresentation :: Text -> Either SDJWTError SDJWTPresentation

-- | Parse tilde-separated format.
--   
--   Low-level function that parses the tilde-separated format and returns
--   the components: (JWT, [Disclosures], Maybe KB-JWT).
--   
--   The last component is <a>Nothing</a> for SD-JWT format (empty string
--   after last tilde) or <a>Just</a> KB-JWT for SD-JWT+KB format.
parseTildeSeparated :: Text -> Either SDJWTError (Text, [EncodedDisclosure], Maybe Text)


-- | Utility functions for SD-JWT operations (low-level).
--   
--   This module provides base64url encoding/decoding, salt generation, and
--   text/ByteString conversions used throughout the SD-JWT library.
--   
--   <h2>Usage</h2>
--   
--   This module contains low-level utilities that are typically used
--   internally by other SD-JWT modules. Most users should use the
--   higher-level APIs in:
--   
--   <ul>
--   <li><a>Issuer</a> - For issuers</li>
--   <li><a>Holder</a> - For holders</li>
--   <li><a>Verifier</a> - For verifiers</li>
--   </ul>
--   
--   These utilities may be useful for: * Advanced use cases requiring
--   custom implementations * Library developers building on top of SD-JWT
--   * Testing and debugging
module SDJWT.Internal.Utils

-- | Base64url encode a ByteString (without padding).
--   
--   This function encodes a ByteString using base64url encoding as
--   specified in RFC 4648 Section 5. The result is URL-safe and does not
--   include padding.
--   
--   <pre>
--   &gt;&gt;&gt; base64urlEncode "Hello, World!"
--   "SGVsbG8sIFdvcmxkIQ"
--   </pre>
base64urlEncode :: ByteString -> Text

-- | Base64url decode a Text (handles padding).
--   
--   This function decodes a base64url-encoded Text back to a ByteString.
--   It handles both padded and unpadded input.
--   
--   Returns <a>Left</a> with an error message if decoding fails.
base64urlDecode :: Text -> Either Text ByteString

-- | Convert Text to ByteString (UTF-8 encoding).
--   
--   This is a convenience function that encodes Text as UTF-8 ByteString.
textToByteString :: Text -> ByteString

-- | Convert ByteString to Text (UTF-8 decoding).
--   
--   This is a convenience function that decodes a UTF-8 ByteString to
--   Text. Note: This will throw an exception if the ByteString is not
--   valid UTF-8. For safe decoding, use <a>decodeUtf8'</a> instead.
byteStringToText :: ByteString -> Text

-- | Hash bytes using the specified hash algorithm.
--   
--   This function computes a cryptographic hash of the input ByteString
--   using the specified hash algorithm (SHA-256, SHA-384, or SHA-512).
--   Returns the hash digest as a ByteString.
hashToBytes :: HashAlgorithm -> ByteString -> ByteString

-- | Split JSON Pointer path by "/", respecting escapes (RFC 6901).
--   
--   This function properly handles JSON Pointer escaping:
--   
--   <ul>
--   <li>"~1" represents a literal forward slash "/"</li>
--   <li>"~0" represents a literal tilde "~"</li>
--   </ul>
--   
--   Examples:
--   
--   <ul>
--   <li>"a/b" → ["a", "b"]</li>
--   <li>"a~1b" → ["a/b"] (escaped slash)</li>
--   <li>"a~0b" → ["a~b"] (escaped tilde)</li>
--   <li>"a~1/b" → ["a/", "b"] (escaped slash becomes "/", then "/" is
--   separator)</li>
--   </ul>
--   
--   Note: This function is designed for relative JSON Pointer paths
--   (without leading "/"). Leading slashes are stripped, trailing slashes
--   don't create empty segments, and consecutive slashes are collapsed.
splitJSONPointer :: Text -> [Text]

-- | Unescape JSON Pointer segment (RFC 6901).
--   
--   Converts escape sequences back to literal characters:
--   
--   <ul>
--   <li>"~1" → "/"</li>
--   <li>"~0" → "~"</li>
--   </ul>
--   
--   Note: Order matters - must replace ~1 before ~0 to avoid
--   double-replacement.
unescapeJSONPointer :: Text -> Text

-- | Constant-time equality comparison for ByteStrings.
--   
--   This function performs a constant-time comparison to prevent timing
--   attacks. It compares two ByteStrings byte-by-byte and always takes the
--   same amount of time regardless of where the first difference occurs.
--   
--   SECURITY: Use this function when comparing cryptographic values like
--   digests, hashes, or other sensitive data that could be exploited via
--   timing attacks.
--   
--   Implementation uses cryptonite's <a>constEq</a> which provides
--   constant-time comparison for ByteArray instances. ByteString is a
--   ByteArray instance.
constantTimeEq :: ByteString -> ByteString -> Bool

-- | Generate a cryptographically secure random salt.
--   
--   Generates 128 bits (16 bytes) of random data as recommended by RFC
--   9901. This salt is used when creating disclosures to ensure that
--   digests cannot be guessed or brute-forced.
--   
--   The salt is generated using cryptonite's secure random number
--   generator.
generateSalt :: MonadIO m => m ByteString

-- | Group paths by their first segment.
--   
--   This is a common pattern for processing nested JSON Pointer paths.
--   Empty paths are grouped under an empty string key.
--   
--   Example: groupPathsByFirstSegment [["a", "b"], ["a", "c"], ["x"]] =
--   Map.fromList [("a", [["b"], ["c"]]), ("x", [[]])]
groupPathsByFirstSegment :: [[Text]] -> Map Text [[Text]]


-- | JWT signing and verification using jose library.
--   
--   This module provides functions for signing and verifying JWTs using
--   the jose library. It supports both Text-based JWK strings and jose JWK
--   objects.
module SDJWT.Internal.JWT

-- | Sign a JWT payload using a private key.
--   
--   Returns the signed JWT as a compact string, or an error. Automatically
--   detects key type and uses:
--   
--   <ul>
--   <li>PS256 for RSA keys (default, RS256 also supported via JWK "alg"
--   field)</li>
--   <li>EdDSA for Ed25519 keys</li>
--   <li>ES256 for EC P-256 keys</li>
--   </ul>
signJWT :: JWKLike jwk => jwk -> Value -> IO (Either SDJWTError Text)

-- | Sign a JWT payload with optional typ header parameter.
--   
--   This function allows setting a typ header for issuer-signed JWTs (RFC
--   9901 Section 9.11 recommends explicit typing, e.g., "sd-jwt" or
--   "example+sd-jwt"). Use <a>signJWT</a> for default behavior (no typ
--   header).
--   
--   Returns the signed JWT as a compact string, or an error.
signJWTWithOptionalTyp :: JWKLike jwk => Maybe Text -> jwk -> Value -> IO (Either SDJWTError Text)

-- | Sign a JWT payload with optional typ and kid header parameters.
--   
--   This function allows setting <tt>typ</tt> and <tt>kid</tt> headers for
--   issuer-signed JWTs. Both headers are supported natively through jose's
--   API.
--   
--   Returns the signed JWT as a compact string, or an error.
signJWTWithHeaders :: JWKLike jwk => Maybe Text -> Maybe Text -> jwk -> Value -> IO (Either SDJWTError Text)

-- | Sign a JWT payload with a custom typ header parameter.
--   
--   This function constructs the JWT header with the specified typ value,
--   then signs the JWT. This is needed for KB-JWT which requires typ:
--   "kb+jwt" (RFC 9901 Section 4.3).
--   
--   Supports all algorithms: EC P-256 (ES256), RSA (PS256 default, RS256
--   also supported), and Ed25519 (EdDSA).
--   
--   Returns the signed JWT as a compact string, or an error.
signJWTWithTyp :: JWKLike jwk => Text -> jwk -> Value -> IO (Either SDJWTError Text)

-- | Verify a JWT signature using a public key.
--   
--   Returns the decoded payload if verification succeeds, or an error.
verifyJWT :: JWKLike jwk => jwk -> Text -> Maybe Text -> IO (Either SDJWTError Value)

-- | Parse a JWK from JSON Text.
--   
--   Parses a JSON Web Key (JWK) from its JSON representation. Supports
--   RSA, Ed25519, and EC P-256 keys.
--   
--   The JWK JSON format follows RFC 7517. Examples:
--   
--   <ul>
--   <li>RSA public key: {"kty":<a>RSA</a>,"n":"...","e":"..."}</li>
--   <li>Ed25519 public key:
--   {"kty":<a>OKP</a>,"crv":<a>Ed25519</a>,"x":"..."}</li>
--   <li>EC P-256 public key:
--   {"kty":<a>EC</a>,"crv":"P-256","x":"...","y":"..."}</li>
--   <li>RSA private key:
--   {"kty":<a>RSA</a>,"n":"...","e":"...","d":"...","p":"...","q":"..."}</li>
--   <li>Ed25519 private key:
--   {"kty":<a>OKP</a>,"crv":<a>Ed25519</a>,"d":"...","x":"..."}</li>
--   <li>EC P-256 private key:
--   {"kty":<a>EC</a>,"crv":"P-256","d":"...","x":"...","y":"..."}</li>
--   </ul>
parseJWKFromText :: Text -> Either SDJWTError JWK

-- | Type class for types that can be converted to a jose JWK.
--   
--   This allows functions to accept both Text (JWK JSON strings) and jose
--   JWK objects. Users can pass JWK strings directly without importing
--   jose, or pass jose JWK objects if they're already working with the
--   jose library.
class JWKLike a

-- | Convert to a jose JWK object.
toJWK :: JWKLike a => a -> Either SDJWTError JWK
instance SDJWT.Internal.JWT.JWKLike Data.Text.Internal.Text
instance SDJWT.Internal.JWT.JWKLike Crypto.JOSE.JWK.JWK


-- | Key Binding JWT support for SD-JWT+KB.
--   
--   This module provides functions for creating and verifying Key Binding
--   JWTs (KB-JWT) as specified in RFC 9901 Section 7. Key Binding provides
--   proof of possession of a key by the holder.
module SDJWT.Internal.KeyBinding

-- | Create a Key Binding JWT.
--   
--   Creates a KB-JWT that proves the holder possesses a specific key. The
--   KB-JWT contains:
--   
--   <ul>
--   <li>aud: Audience (verifier identifier)</li>
--   <li>nonce: Nonce provided by verifier</li>
--   <li>iat: Issued at timestamp</li>
--   <li>sd_hash: Hash of the SD-JWT presentation</li>
--   <li>Optional additional claims (e.g., exp for expiration time)</li>
--   </ul>
--   
--   Note: RFC 9901 Section 4.3 states that additional claims in
--   <tt>optionalClaims</tt> SHOULD be avoided unless there is a compelling
--   reason, as they may harm interoperability.
--   
--   Returns the signed KB-JWT as a compact JWT string.
createKeyBindingJWT :: JWKLike jwk => HashAlgorithm -> jwk -> Text -> Text -> Int64 -> SDJWTPresentation -> Object -> IO (Either SDJWTError Text)

-- | Compute sd_hash for key binding.
--   
--   The sd_hash is computed as the hash of the serialized SD-JWT
--   presentation (without the KB-JWT part). This hash is included in the
--   KB-JWT to bind it to the specific presentation.
--   
--   The hash is computed over the US-ASCII bytes of the presentation
--   string (per RFC 9901). Since the serialized presentation contains only
--   ASCII characters (base64url-encoded strings and tilde separators),
--   UTF-8 encoding produces identical bytes to US-ASCII.
computeSDHash :: HashAlgorithm -> SDJWTPresentation -> Digest

-- | Verify a Key Binding JWT.
--   
--   Verifies that:
--   
--   <ol>
--   <li>The KB-JWT signature is valid (using holder's public key)</li>
--   <li>The sd_hash in the KB-JWT matches the computed hash of the
--   presentation</li>
--   <li>The nonce, audience, and iat claims are present and valid</li>
--   </ol>
--   
--   Returns 'Right ()' if verification succeeds, <a>Left</a> with error
--   otherwise.
verifyKeyBindingJWT :: JWKLike jwk => HashAlgorithm -> jwk -> Text -> SDJWTPresentation -> IO (Either SDJWTError ())

-- | Add key binding to a presentation.
--   
--   Creates a KB-JWT and adds it to the presentation, converting it to
--   SD-JWT+KB format. The KB-JWT includes required claims (<tt>aud</tt>,
--   <tt>nonce</tt>, <tt>iat</tt>, <tt>sd_hash</tt>) plus any optional
--   claims provided. Standard JWT claims like <tt>exp</tt> (expiration
--   time) and <tt>nbf</tt> (not before) will be automatically validated
--   during verification if present.
--   
--   Note: RFC 9901 Section 4.3 states that additional claims in
--   <tt>optionalClaims</tt> SHOULD be avoided unless there is a compelling
--   reason, as they may harm interoperability.
addKeyBindingToPresentation :: JWKLike jwk => HashAlgorithm -> jwk -> Text -> Text -> Int64 -> SDJWTPresentation -> Object -> IO (Either SDJWTError SDJWTPresentation)


-- | Disclosure creation, encoding, and decoding (low-level).
--   
--   Disclosures are base64url-encoded JSON arrays that contain the
--   cleartext values of selectively disclosable claims. This module
--   provides functions to create disclosures for object properties and
--   array elements, and to encode/decode them.
--   
--   <h2>Usage</h2>
--   
--   This module contains low-level disclosure utilities that are typically
--   used internally by other SD-JWT modules. Most users should use the
--   higher-level APIs in:
--   
--   <ul>
--   <li><a>Issuer</a> - For issuers (handles disclosure creation
--   internally)</li>
--   <li><a>Holder</a> - For holders (handles disclosure selection
--   internally)</li>
--   <li><a>Verifier</a> - For verifiers (handles disclosure verification
--   internally)</li>
--   </ul>
--   
--   These utilities may be useful for:
--   
--   <ul>
--   <li>Advanced use cases requiring custom disclosure handling</li>
--   <li>Library developers building on top of SD-JWT</li>
--   <li>Testing and debugging</li>
--   </ul>
module SDJWT.Internal.Disclosure

-- | Create disclosure for object property: [salt, claim_name,
--   claim_value].
--   
--   Creates a disclosure for a selectively disclosable object property.
--   The disclosure is a JSON array containing:
--   
--   <ol>
--   <li>The salt (base64url-encoded)</li>
--   <li>The claim name</li>
--   <li>The claim value</li>
--   </ol>
--   
--   The result is base64url-encoded as required by RFC 9901.
createObjectDisclosure :: Salt -> Text -> Value -> Either SDJWTError EncodedDisclosure

-- | Create disclosure for array element: [salt, claim_value].
--   
--   Creates a disclosure for a selectively disclosable array element. The
--   disclosure is a JSON array containing:
--   
--   <ol>
--   <li>The salt (base64url-encoded)</li>
--   <li>The array element value</li>
--   </ol>
--   
--   Note: Array element disclosures do not include a claim name. The
--   result is base64url-encoded as required by RFC 9901.
createArrayDisclosure :: Salt -> Value -> Either SDJWTError EncodedDisclosure

-- | Decode disclosure from base64url.
--   
--   Decodes a base64url-encoded disclosure string back into a
--   <a>Disclosure</a> value. The disclosure must be a valid JSON array
--   with either 2 elements (for array disclosures) or 3 elements (for
--   object disclosures).
--   
--   Returns <a>Left</a> with an error if the disclosure format is invalid.
decodeDisclosure :: EncodedDisclosure -> Either SDJWTError Disclosure

-- | Encode disclosure to base64url.
--   
--   Encodes a <a>Disclosure</a> value to its base64url-encoded string
--   representation. This is the inverse of <a>decodeDisclosure</a>.
encodeDisclosure :: Disclosure -> EncodedDisclosure

-- | Extract salt from disclosure.
--   
--   Returns the salt value used in the disclosure. The salt is the same
--   regardless of whether it's an object or array disclosure.
getDisclosureSalt :: Disclosure -> Salt

-- | Extract claim name (for object disclosures).
--   
--   Returns <a>Just</a> the claim name for object disclosures, or
--   <a>Nothing</a> for array element disclosures (which don't have claim
--   names).
getDisclosureClaimName :: Disclosure -> Maybe Text

-- | Extract claim value.
--   
--   Returns the claim value from the disclosure, regardless of whether
--   it's an object or array disclosure.
getDisclosureValue :: Disclosure -> Value


-- | Hash computation and verification for SD-JWT disclosures (low-level).
--   
--   This module provides functions for computing digests of disclosures
--   and verifying that digests match disclosures. All three hash
--   algorithms required by RFC 9901 are supported: SHA-256, SHA-384, and
--   SHA-512.
--   
--   <h2>Usage</h2>
--   
--   This module contains low-level hash and digest utilities that are
--   typically used internally by other SD-JWT modules. Most users should
--   use the higher-level APIs in:
--   
--   <ul>
--   <li><a>Issuer</a> - For issuers (handles digest computation
--   internally)</li>
--   <li><a>Holder</a> - For holders (handles digest computation
--   internally)</li>
--   <li><a>Verifier</a> - For verifiers (handles digest verification
--   internally)</li>
--   </ul>
--   
--   These utilities may be useful for:
--   
--   <ul>
--   <li>Advanced use cases requiring custom digest computation</li>
--   <li>Library developers building on top of SD-JWT</li>
--   <li>Testing and debugging</li>
--   </ul>
module SDJWT.Internal.Digest

-- | Compute digest of a disclosure.
--   
--   The digest is computed over the US-ASCII bytes of the
--   base64url-encoded disclosure string (per RFC 9901). The bytes of the
--   hash output are then base64url encoded to produce the final digest.
--   
--   This follows the convention in JWS (RFC 7515) and JWE (RFC 7516).
--   
--   Note: RFC 9901 requires US-ASCII encoding. Since base64url strings
--   contain only ASCII characters (A-Z, a-z, 0-9, -, _), UTF-8 encoding
--   produces identical bytes to US-ASCII for these strings.
computeDigest :: HashAlgorithm -> EncodedDisclosure -> Digest

-- | Compute digest text (string) from a disclosure.
--   
--   Convenience function that computes the digest and extracts the text.
--   Equivalent to <tt>unDigest . computeDigest</tt>.
computeDigestText :: HashAlgorithm -> EncodedDisclosure -> Text

-- | Verify that a digest matches a disclosure.
--   
--   Computes the digest of the disclosure using the specified hash
--   algorithm and compares it to the expected digest using constant-time
--   comparison. Returns <a>True</a> if they match.
--   
--   SECURITY: Uses constant-time comparison to prevent timing attacks.
--   This is critical for cryptographic verification operations.
verifyDigest :: HashAlgorithm -> Digest -> EncodedDisclosure -> Bool

-- | Parse hash algorithm from text identifier.
--   
--   Parses hash algorithm names from the _sd_alg claim. Returns
--   <a>Nothing</a> if the algorithm is not recognized.
parseHashAlgorithm :: Text -> Maybe HashAlgorithm

-- | Default hash algorithm (SHA-256 per RFC 9901).
--   
--   When the _sd_alg claim is not present in an SD-JWT, SHA-256 is used as
--   the default hash algorithm.
defaultHashAlgorithm :: HashAlgorithm

-- | Convert hash algorithm to text identifier.
--   
--   Returns the hash algorithm name as specified in RFC 9901: "sha-256",
--   "sha-384", or "sha-512".
hashAlgorithmToText :: HashAlgorithm -> Text

-- | Recursively extract digests from JSON value (_sd arrays and array
--   ellipsis objects).
--   
--   This function extracts all digests from a JSON value by:
--   
--   <ol>
--   <li>Looking for _sd arrays in objects and extracting string
--   digests</li>
--   <li>Looking for {"...": "<a>digest</a>"} objects in arrays</li>
--   <li>Recursively processing nested structures</li>
--   </ol>
--   
--   Used for extracting digests from SD-JWT payloads and disclosure
--   values.
--   
--   Per RFC 9901 Section 4.2.4.1, _sd arrays MUST contain only strings
--   (digests). Returns an error if non-string values are found in _sd
--   arrays.
extractDigestsFromValue :: Value -> Either SDJWTError [Digest]

-- | Extract digest strings from an _sd array in a JSON object.
--   
--   This helper function extracts string digests from the _sd array field
--   of a JSON object. Returns an empty list if _sd is not present or not
--   an array. This is a convenience function for cases where you only need
--   the digest strings, not the full Digest type.
extractDigestStringsFromSDArray :: Object -> [Text]


-- | SD-JWT issuance: Creating SD-JWTs from claims sets.
--   
--   This module provides functions for creating SD-JWTs on the issuer
--   side. It handles marking claims as selectively disclosable, creating
--   disclosures, computing digests, and building the final signed JWT.
--   
--   <h2>Nested Structures</h2>
--   
--   This module supports nested structures (RFC 9901 Sections 6.2 and 6.3)
--   using JSON Pointer syntax (RFC 6901) for specifying nested claim
--   paths.
--   
--   <h3>JSON Pointer Syntax</h3>
--   
--   Nested paths use forward slash (<tt>/</tt>) as a separator. Paths can
--   refer to both object properties and array elements:
--   
--   <pre>
--   -- Object properties
--   ["address/street_address", "address/locality"]
--   </pre>
--   
--   This marks <tt>street_address</tt> and <tt>locality</tt> within the
--   <tt>address</tt> object as selectively disclosable.
--   
--   <pre>
--   -- Array elements
--   ["nationalities/0", "nationalities/2"]
--   </pre>
--   
--   This marks elements at indices 0 and 2 in the <tt>nationalities</tt>
--   array as selectively disclosable.
--   
--   <pre>
--   -- Mixed object and array paths
--   ["address/street_address", "nationalities/1"]
--   </pre>
--   
--   <h3>Ambiguity Resolution</h3>
--   
--   Paths with numeric segments (e.g., <tt>["x/22"]</tt>) are ambiguous:
--   they could refer to an array element at index 22, or an object
--   property with key <tt>"22"</tt>. The library resolves this ambiguity
--   by checking the actual claim type at runtime:
--   
--   <ul>
--   <li>If <tt>x</tt> is an array → <tt>["x/22"]</tt> refers to array
--   element at index 22</li>
--   <li>If <tt>x</tt> is an object → <tt>["x/22"]</tt> refers to object
--   property <tt>"22"</tt></li>
--   </ul>
--   
--   This follows JSON Pointer semantics (RFC 6901) where the path alone
--   doesn't determine the type.
--   
--   <h3>Escaping Special Characters</h3>
--   
--   JSON Pointer provides escaping for keys containing special characters:
--   
--   <ul>
--   <li><tt>~1</tt> represents a literal forward slash <tt>/</tt></li>
--   <li><tt>~0</tt> represents a literal tilde <tt>~</tt></li>
--   </ul>
--   
--   Examples:
--   
--   <ul>
--   <li><tt>["contact~1email"]</tt> → marks the literal key
--   <tt>"contact/email"</tt> as selectively disclosable</li>
--   <li><tt>["user~0name"]</tt> → marks the literal key
--   <tt>"user~name"</tt> as selectively disclosable</li>
--   <li><tt>["address/email"]</tt> → marks <tt>email</tt> within
--   <tt>address</tt> object as selectively disclosable</li>
--   </ul>
--   
--   <h3>Nested Structure Patterns</h3>
--   
--   The module supports two patterns for nested structures:
--   
--   <ol>
--   <li><i>Structured SD-JWT</i> (Section 6.2): Parent object stays in
--   payload with <tt>_sd</tt> array containing digests for
--   sub-claims.</li>
--   <li><i>Recursive Disclosures</i> (Section 6.3): Parent is selectively
--   disclosable, and its disclosure contains an <tt>_sd</tt> array with
--   digests for sub-claims.</li>
--   </ol>
--   
--   The pattern is automatically detected based on whether the parent
--   claim is also in the selective claims list.
--   
--   <h3>Examples</h3>
--   
--   Structured SD-JWT (Section 6.2):
--   
--   <pre>
--   buildSDJWTPayload SHA256 ["address/street_address", "address/locality"] claims
--   </pre>
--   
--   This creates a payload where <tt>address</tt> object contains an
--   <tt>_sd</tt> array.
--   
--   Recursive Disclosures (Section 6.3):
--   
--   <pre>
--   buildSDJWTPayload SHA256 ["address", "address/street_address", "address/locality"] claims
--   </pre>
--   
--   This creates a payload where <tt>address</tt> digest is in top-level
--   <tt>_sd</tt>, and the <tt>address</tt> disclosure contains an
--   <tt>_sd</tt> array with sub-claim digests.
--   
--   Array Elements:
--   
--   <pre>
--   buildSDJWTPayload SHA256 ["nationalities/0", "nationalities/2"] claims
--   </pre>
--   
--   This marks array elements at indices 0 and 2 as selectively
--   disclosable.
--   
--   Nested Arrays:
--   
--   <pre>
--   buildSDJWTPayload SHA256 ["nested_array/0/0", "nested_array/0/1", "nested_array/1/0"] claims
--   </pre>
--   
--   This marks nested array elements. The path
--   <tt>["nested_array/0/0"]</tt> refers to element at index 0 of the
--   array at index 0 of <tt>nested_array</tt>.
--   
--   Mixed Object and Array Paths:
--   
--   <pre>
--   buildSDJWTPayload SHA256 ["address/street_address", "nationalities/1"] claims
--   </pre>
--   
--   This marks both an object property and an array element as selectively
--   disclosable.
--   
--   <h2>Decoy Digests</h2>
--   
--   Decoy digests are optional random digests added to <tt>_sd</tt> arrays
--   to obscure the actual number of selectively disclosable claims. This
--   is useful for privacy-preserving applications where you want to hide
--   how many claims are selectively disclosable.
--   
--   To use decoy digests:
--   
--   <ol>
--   <li>Build the SD-JWT payload using buildSDJWTPayload</li>
--   <li>Generate decoy digests using addDecoyDigest</li>
--   <li>Manually add them to the <tt>_sd</tt> array in the payload</li>
--   <li>Sign the modified payload</li>
--   </ol>
--   
--   Example:
--   
--   <pre>
--   -- Build the initial payload
--   (payload, disclosures) &lt;- buildSDJWTPayload SHA256 ["given_name", "email"] claims
--   
--   -- Generate decoy digests
--   decoy1 &lt;- addDecoyDigest SHA256
--   decoy2 &lt;- addDecoyDigest SHA256
--   
--   -- Add decoy digests to the _sd array
--   case payloadValue payload of
--     Aeson.Object obj -&gt; do
--       case KeyMap.lookup "_sd" obj of
--         Just (Aeson.Array sdArray) -&gt; do
--           let decoyDigests = [Aeson.String (unDigest decoy1), Aeson.String (unDigest decoy2)]
--           let updatedSDArray = sdArray &lt;&gt; V.fromList decoyDigests
--           let updatedObj = KeyMap.insert "_sd" (Aeson.Array updatedSDArray) obj
--           -- Sign the updated payload...
--         _ -&gt; -- Handle error
--     _ -&gt; -- Handle error
--   </pre>
--   
--   During verification, decoy digests that don't match any disclosure are
--   automatically ignored, so they don't affect verification.
module SDJWT.Internal.Issuance

-- | Create a complete SD-JWT (signed).
--   
--   This function creates an SD-JWT and signs it using the issuer's key.
--   Creates a complete SD-JWT with signed JWT using jose.
--   
--   Returns the created SD-JWT or an error.
--   
--   <h2>Standard JWT Claims</h2>
--   
--   Standard JWT claims (RFC 7519) can be included in the <tt>claims</tt>
--   map and will be preserved in the issuer-signed JWT payload. During
--   verification, standard claims like <tt>exp</tt> and <tt>nbf</tt> are
--   automatically validated if present. See RFC 9901 Section 4.1 for
--   details.
--   
--   <h2>Example</h2>
--   
--   <pre>
--   -- Create SD-JWT without typ header
--   result &lt;- createSDJWT Nothing SHA256 issuerKey ["given_name", "family_name"] claims
--   
--   -- Create SD-JWT with typ header
--   result &lt;- createSDJWT (Just "sd-jwt") SHA256 issuerKey ["given_name", "family_name"] claims
--   
--   -- Create SD-JWT with expiration time
--   let claimsWithExp = Map.insert "exp" (Aeson.Number (fromIntegral expirationTime)) claims
--   result &lt;- createSDJWT (Just "sd-jwt") SHA256 issuerKey ["given_name"] claimsWithExp
--   </pre>
createSDJWT :: JWKLike jwk => Maybe Text -> Maybe Text -> HashAlgorithm -> jwk -> [Text] -> Object -> IO (Either SDJWTError SDJWT)

-- | Create an SD-JWT with optional typ header and decoy digests.
--   
--   This function is similar to <a>createSDJWT</a> but automatically adds
--   a specified number of decoy digests to the <tt>_sd</tt> array to
--   obscure the actual number of selectively disclosable claims.
--   
--   Returns the created SD-JWT or an error.
--   
--   <h2>Standard JWT Claims</h2>
--   
--   Standard JWT claims (RFC 7519) can be included in the <tt>claims</tt>
--   map and will be preserved in the issuer-signed JWT payload. During
--   verification, standard claims like <tt>exp</tt> and <tt>nbf</tt> are
--   automatically validated if present. See RFC 9901 Section 4.1 for
--   details.
--   
--   <h2>Example</h2>
--   
--   <pre>
--   -- Create SD-JWT with 5 decoy digests, no typ header
--   result &lt;- createSDJWTWithDecoys Nothing SHA256 issuerKey ["given_name", "email"] claims 5
--   
--   -- Create SD-JWT with 5 decoy digests and typ header
--   result &lt;- createSDJWTWithDecoys (Just "sd-jwt") SHA256 issuerKey ["given_name", "email"] claims 5
--   </pre>
createSDJWTWithDecoys :: JWKLike jwk => Maybe Text -> Maybe Text -> HashAlgorithm -> jwk -> [Text] -> Object -> Int -> IO (Either SDJWTError SDJWT)

-- | Generate a decoy digest.
--   
--   Decoy digests are random digests that don't correspond to any
--   disclosure. They are used to obscure the actual number of selectively
--   disclosable claims.
--   
--   According to RFC 9901 Section 4.2.5, decoy digests should be created
--   by hashing over a cryptographically secure random number, then
--   base64url encoding.
--   
--   <h2>Advanced Use</h2>
--   
--   Decoy digests are an advanced feature used to hide the number of
--   selectively disclosable claims. They are optional and must be manually
--   added to the _sd array if you want to obscure the actual number of
--   selectively disclosable claims.
--   
--   To use decoy digests, call this function to generate them and manually
--   add them to the _sd array in your payload. This is useful for
--   privacy-preserving applications where you want to hide how many claims
--   are selectively disclosable.
addDecoyDigest :: HashAlgorithm -> IO Digest
buildSDJWTPayload :: HashAlgorithm -> [Text] -> Object -> IO (Either SDJWTError (SDJWTPayload, [EncodedDisclosure]))

-- | Add holder's public key to claims as a <tt>cnf</tt> claim (RFC 7800).
--   
--   This convenience function adds the holder's public key to the claims
--   map in the format required by RFC 7800 for key confirmation:
--   
--   <pre>
--   {
--     "cnf": {
--       "jwk": "<a>holderPublicKeyJWK</a>"
--     }
--   }
--   </pre>
--   
--   The <tt>cnf</tt> claim is used during key binding to prove that the
--   holder possesses the corresponding private key.
--   
--   <h2>Example</h2>
--   
--   <pre>
--   let holderPublicKeyJWK = "{"kty":"EC","crv":"P-256","x":"...","y":"..."}"
--   let claimsWithCnf = addHolderKeyToClaims holderPublicKeyJWK claims
--   result &lt;- createSDJWT (Just "sd-jwt") SHA256 issuerKey ["given_name"] claimsWithCnf
--   </pre>
--   
--   <h2>See Also</h2>
--   
--   <ul>
--   <li>RFC 7800: Proof-of-Possession Key Semantics for JSON Web Tokens
--   (JWT)</li>
--   <li>RFC 9901 Section 4.3: Key Binding</li>
--   </ul>
addHolderKeyToClaims :: Text -> Object -> Object


-- | SD-JWT verification: Verifying SD-JWT presentations.
--   
--   This module provides functions for verifying SD-JWT presentations on
--   the verifier side. It handles signature verification, disclosure
--   validation, and payload processing.
module SDJWT.Internal.Verification

-- | Complete SD-JWT verification.
--   
--   This function performs all verification steps:
--   
--   <ol>
--   <li>Parses the presentation</li>
--   <li>Verifies issuer signature (required)</li>
--   <li>Validates standard JWT claims (if present): <tt>exp</tt>
--   (expiration time), <tt>nbf</tt> (not before), etc.</li>
--   <li>Extracts hash algorithm</li>
--   <li>Verifies disclosures match digests</li>
--   <li>Verifies key binding (if present)</li>
--   <li>Processes payload to reconstruct claims</li>
--   </ol>
--   
--   Returns the processed payload with all claims (both regular
--   non-selectively-disclosable claims and disclosed
--   selectively-disclosable claims). If a KB-JWT was present and verified,
--   the <a>keyBindingInfo</a> field will contain the holder's public key
--   extracted from the <tt>cnf</tt> claim, allowing the verifier to use it
--   for subsequent operations.
--   
--   <h2>Standard JWT Claims Validation</h2>
--   
--   Standard JWT claims (RFC 7519) included in the issuer-signed JWT are
--   automatically validated:
--   
--   <ul>
--   <li><tt>exp</tt> (expiration time): Token is rejected if expired</li>
--   <li><tt>nbf</tt> (not before): Token is rejected if not yet valid</li>
--   <li>Other standard claims are preserved but not validated by this
--   library</li>
--   </ul>
--   
--   For testing or debugging purposes where signature verification should
--   be skipped, use <a>verifySDJWTWithoutSignature</a> instead.
verifySDJWT :: JWKLike jwk => jwk -> SDJWTPresentation -> Maybe Text -> IO (Either SDJWTError ProcessedSDJWTPayload)

-- | Verify key binding in a presentation.
--   
--   Verifies the Key Binding JWT if present in the presentation. This
--   includes verifying the KB-JWT signature and sd_hash.
verifyKeyBinding :: JWKLike jwk => HashAlgorithm -> jwk -> SDJWTPresentation -> IO (Either SDJWTError ())

-- | Verify SD-JWT issuer signature.
--   
--   Verifies the signature on the issuer-signed JWT using the issuer's
--   public key.
verifySDJWTSignature :: JWKLike jwk => jwk -> SDJWTPresentation -> Maybe Text -> IO (Either SDJWTError ())

-- | SD-JWT verification without signature verification.
--   
--   This function performs verification steps 3-6 of <a>verifySDJWT</a>
--   but skips signature verification. This is useful for testing or
--   debugging, but should NOT be used in production as it does not verify
--   the authenticity of the JWT.
--   
--   WARNING: This function does not verify the issuer signature. Only use
--   this function when signature verification is not required (e.g., in
--   tests or when verifying locally-generated JWTs).
verifySDJWTWithoutSignature :: SDJWTPresentation -> IO (Either SDJWTError ProcessedSDJWTPayload)

-- | Verify that all disclosures match digests in the payload.
--   
--   This function:
--   
--   <ol>
--   <li>Computes digest for each disclosure</li>
--   <li>Verifies each digest exists in the payload's _sd array</li>
--   <li>Checks for duplicate disclosures</li>
--   </ol>
verifyDisclosures :: HashAlgorithm -> SDJWTPresentation -> Either SDJWTError ()

-- | Process SD-JWT payload by replacing digests with disclosure values.
--   
--   This function reconstructs the full claims set by:
--   
--   <ol>
--   <li>Starting with regular (non-selectively disclosable) claims</li>
--   <li>Replacing digests in _sd arrays with actual claim values from
--   disclosures</li>
--   </ol>
processPayload :: HashAlgorithm -> SDJWTPayload -> [EncodedDisclosure] -> Maybe KeyBindingInfo -> Either SDJWTError ProcessedSDJWTPayload

-- | Extract hash algorithm from presentation.
--   
--   Parses the JWT payload and extracts the _sd_alg claim, defaulting to
--   SHA-256.
extractHashAlgorithm :: SDJWTPresentation -> Either SDJWTError HashAlgorithm

-- | Parse payload from JWT.
--   
--   | Parse JWT payload from a JWT string (advanced/internal use).
--   
--   Extracts and decodes the JWT payload (middle part) from a JWT string.
--   This function properly decodes the base64url-encoded payload and
--   parses it as JSON.
--   
--   This function is exported for advanced use cases and internal library
--   use. Most users should use <a>verifySDJWT</a> or
--   <a>verifySDJWTWithoutSignature</a> instead, which handle payload
--   parsing internally.
--   
--   This function is used internally by:
--   
--   <ul>
--   <li><a>Presentation</a> - To parse payloads when selecting
--   disclosures</li>
--   <li><a>verifyDisclosures</a> - To extract digests from payloads</li>
--   <li><a>extractHashAlgorithm</a> - To extract hash algorithm from
--   payloads</li>
--   </ul>
--   
--   <h2>Advanced/Internal Use</h2>
--   
--   This function is primarily used internally by other modules (e.g.,
--   <a>Presentation</a>). Most users should use higher-level functions
--   like <a>verifySDJWT</a> instead. Only use this function directly if
--   you need fine-grained control over JWT parsing.
parsePayloadFromJWT :: Text -> Either SDJWTError SDJWTPayload

-- | Extract regular (non-selectively disclosable) claims from payload.
--   
--   JWT payloads must be JSON objects (RFC 7519), so this function only
--   accepts Aeson.Object values. Returns an error if given a non-object
--   value.
extractRegularClaims :: Value -> Either SDJWTError Object

-- | Extract digests from payload's _sd array and arrays with ellipsis
--   objects.
extractDigestsFromPayload :: SDJWTPayload -> Either SDJWTError [Digest]


-- | SD-JWT presentation: Creating presentations with selected disclosures.
--   
--   This module provides functions for creating SD-JWT presentations on
--   the holder side. The holder selects which disclosures to include when
--   presenting to a verifier.
module SDJWT.Internal.Presentation

-- | Create a presentation with selected disclosures.
--   
--   This is a simple function that creates an SDJWTPresentation from an
--   SDJWT and a list of selected disclosures. The selected disclosures
--   must be a subset of the disclosures in the original SDJWT.
createPresentation :: SDJWT -> [EncodedDisclosure] -> SDJWTPresentation

-- | Select disclosures from an SD-JWT (more flexible version).
--   
--   This function allows selecting disclosures directly by providing the
--   disclosure objects themselves. Useful when you already know which
--   disclosures to include.
selectDisclosures :: SDJWT -> [EncodedDisclosure] -> Either SDJWTError SDJWTPresentation

-- | Select disclosures from an SD-JWT based on claim names.
--   
--   This function:
--   
--   <ol>
--   <li>Decodes all disclosures from the SD-JWT</li>
--   <li>Filters disclosures to include only those matching the provided
--   claim names</li>
--   <li>Handles recursive disclosures (Section 6.3): when selecting nested
--   claims, automatically includes parent disclosures if they are
--   recursively disclosable</li>
--   <li>Validates disclosure dependencies (ensures all required parent
--   disclosures are present)</li>
--   <li>Returns a presentation with the selected disclosures</li>
--   </ol>
--   
--   Note: This function validates that the selected disclosures exist in
--   the SD-JWT. Supports JSON Pointer syntax for nested paths:
--   
--   <ul>
--   <li>Object properties: <tt>["address/street_address",
--   "address/locality"]</tt></li>
--   <li>Array elements: <tt>["nationalities/0",
--   "nationalities/2"]</tt></li>
--   <li>Mixed paths: <tt>["address/street_address",
--   "nationalities/1"]</tt></li>
--   <li>Nested arrays: <tt>["nested_array/0/0",
--   "nested_array/1/1"]</tt></li>
--   </ul>
--   
--   Paths with numeric segments (e.g., <tt>["x/22"]</tt>) are resolved by
--   checking the actual claim type: if <tt>x</tt> is an array, it refers
--   to index 22; if <tt>x</tt> is an object, it refers to property
--   <tt>"22"</tt>.
selectDisclosuresByNames :: SDJWT -> [Text] -> Either SDJWTError SDJWTPresentation

-- | Add key binding to a presentation.
--   
--   Creates a Key Binding JWT and adds it to the presentation, converting
--   it to SD-JWT+KB format. The KB-JWT proves that the holder possesses a
--   specific key.
--   
--   Returns the presentation with key binding added, or an error if KB-JWT
--   creation fails.
addKeyBinding :: JWKLike jwk => HashAlgorithm -> jwk -> Text -> Text -> Int64 -> SDJWTPresentation -> Object -> IO (Either SDJWTError SDJWTPresentation)


-- | Convenience module for SD-JWT holders.
--   
--   This module provides everything needed to receive SD-JWTs and create
--   presentations. It exports a focused API for the holder role, excluding
--   modules that holders don't need (like Issuance and Verification).
--   
--   <h2>Usage</h2>
--   
--   For holders, import this module:
--   
--   <pre>
--   import SDJWT.Holder
--   </pre>
--   
--   This gives you access to:
--   
--   <ul>
--   <li>Core data types (HashAlgorithm, SDJWT, SDJWTPresentation,
--   etc.)</li>
--   <li>Serialization functions (<a>deserializeSDJWT</a>,
--   <a>serializePresentation</a>)</li>
--   <li>Presentation functions (<a>selectDisclosuresByNames</a>)</li>
--   <li>Key binding functions (<a>addKeyBindingToPresentation</a>)</li>
--   </ul>
--   
--   <h2>Creating Presentations</h2>
--   
--   The main workflow for holders is:
--   
--   <pre>
--   -- 1. Deserialize SD-JWT received from issuer
--   case deserializeSDJWT sdjwtText of
--     Right sdjwt -&gt; do
--       -- 2. Select which disclosures to include
--       -- Examples of different selection patterns:
--       --   Top-level claims: ["given_name", "email"]
--       --   Nested object claims: ["address/street_address", "address/locality"]
--       --   Array elements: ["nationalities/0", "nationalities/2"]
--       --   Mixed paths: ["address/street_address", "nationalities/1"]
--       case selectDisclosuresByNames sdjwt ["given_name", "email"] of
--         Right presentation -&gt; do
--           -- 3. Optionally add key binding for proof of possession
--           holderPrivateKeyJWK &lt;- loadPrivateKeyJWK
--           let audience = "verifier.example.com"
--           let nonce = "random-nonce-12345"
--           let issuedAt = 1683000000 :: Int64
--           -- Optional: Add standard JWT claims like exp (expiration time) to KB-JWT
--           -- These claims will be automatically validated during verification if present
--           let expirationTime = issuedAt + 3600  -- 1 hour from issued time
--           let optionalClaims = Aeson.object [("exp", Aeson.Number (fromIntegral expirationTime))]
--           kbResult &lt;- addKeyBindingToPresentation SHA256 holderPrivateKeyJWK audience nonce issuedAt presentation optionalClaims
--           case kbResult of
--             Right presentationWithKB -&gt; do
--               -- 4. Serialize presentation to send to verifier
--               let serialized = serializePresentation presentationWithKB
--               -- Send serialized presentation...
--             Left err -&gt; -- Handle error
--         Left err -&gt; -- Handle error
--     Left err -&gt; -- Handle error
--   </pre>
--   
--   <h2>Optional Claims in KB-JWT</h2>
--   
--   The <tt>optionalClaims</tt> parameter allows adding standard JWT
--   claims (RFC 7519) to the KB-JWT, such as <tt>exp</tt> (expiration
--   time) or <tt>nbf</tt> (not before). These claims will be automatically
--   validated during verification if present. Pass <tt>Aeson.object
--   []</tt> for no additional claims. Note: RFC 9901 Section 4.3 states
--   that additional claims SHOULD be avoided unless there is a compelling
--   reason, as they may harm interoperability.
--   
--   For advanced use cases (e.g., creating presentations manually or
--   computing SD hash separately), import <a>Presentation</a> or
--   <a>KeyBinding</a> to access additional low-level functions.
module SDJWT.Holder

-- | Deserialize SD-JWT from tilde-separated format.
--   
--   Parses a tilde-separated string into an <a>SDJWT</a> structure.
--   Returns an error if the format is invalid or if a Key Binding JWT is
--   present (use <a>deserializePresentation</a> for SD-JWT+KB).
deserializeSDJWT :: Text -> Either SDJWTError SDJWT

-- | Serialize SD-JWT presentation.
--   
--   Format: <tt><a>JWT</a>~<a>1</a>~...~<a>N</a>~[<a>KB-JWT</a>]</tt>
--   
--   If a Key Binding JWT is present, it is included as the last component.
--   Otherwise, the last component is empty (just a trailing tilde).
serializePresentation :: SDJWTPresentation -> Text

-- | Select disclosures from an SD-JWT based on claim names.
--   
--   This function:
--   
--   <ol>
--   <li>Decodes all disclosures from the SD-JWT</li>
--   <li>Filters disclosures to include only those matching the provided
--   claim names</li>
--   <li>Handles recursive disclosures (Section 6.3): when selecting nested
--   claims, automatically includes parent disclosures if they are
--   recursively disclosable</li>
--   <li>Validates disclosure dependencies (ensures all required parent
--   disclosures are present)</li>
--   <li>Returns a presentation with the selected disclosures</li>
--   </ol>
--   
--   Note: This function validates that the selected disclosures exist in
--   the SD-JWT. Supports JSON Pointer syntax for nested paths:
--   
--   <ul>
--   <li>Object properties: <tt>["address/street_address",
--   "address/locality"]</tt></li>
--   <li>Array elements: <tt>["nationalities/0",
--   "nationalities/2"]</tt></li>
--   <li>Mixed paths: <tt>["address/street_address",
--   "nationalities/1"]</tt></li>
--   <li>Nested arrays: <tt>["nested_array/0/0",
--   "nested_array/1/1"]</tt></li>
--   </ul>
--   
--   Paths with numeric segments (e.g., <tt>["x/22"]</tt>) are resolved by
--   checking the actual claim type: if <tt>x</tt> is an array, it refers
--   to index 22; if <tt>x</tt> is an object, it refers to property
--   <tt>"22"</tt>.
selectDisclosuresByNames :: SDJWT -> [Text] -> Either SDJWTError SDJWTPresentation

-- | Add key binding to a presentation.
--   
--   Creates a KB-JWT and adds it to the presentation, converting it to
--   SD-JWT+KB format. The KB-JWT includes required claims (<tt>aud</tt>,
--   <tt>nonce</tt>, <tt>iat</tt>, <tt>sd_hash</tt>) plus any optional
--   claims provided. Standard JWT claims like <tt>exp</tt> (expiration
--   time) and <tt>nbf</tt> (not before) will be automatically validated
--   during verification if present.
--   
--   Note: RFC 9901 Section 4.3 states that additional claims in
--   <tt>optionalClaims</tt> SHOULD be avoided unless there is a compelling
--   reason, as they may harm interoperability.
addKeyBindingToPresentation :: JWKLike jwk => HashAlgorithm -> jwk -> Text -> Text -> Int64 -> SDJWTPresentation -> Object -> IO (Either SDJWTError SDJWTPresentation)


-- | Convenience module for SD-JWT issuers.
--   
--   This module provides everything needed to create and issue SD-JWTs. It
--   exports a focused API for the issuer role, excluding modules that
--   issuers don't need (like Presentation and Verification).
--   
--   <h2>Security Warning: EC Signing Timing Attack</h2>
--   
--   ⚠️ When using Elliptic Curve (EC) keys (ES256 algorithm), be aware
--   that the underlying <tt>jose</tt> library's EC signing implementation
--   may be vulnerable to timing attacks. This affects <i>signing only</i>,
--   not verification.
--   
--   For applications where timing attacks are a concern, consider using
--   RSA-PSS (PS256) or Ed25519 (EdDSA) keys instead, which do not have
--   this limitation.
--   
--   Note: RS256 (RSA-PKCS#1 v1.5) is deprecated for encryption per
--   draft-ietf-jose-deprecate-none-rsa15, but remains valid for
--   signatures. PS256 (RSA-PSS) is the recommended RSA algorithm and is
--   used by default for RSA keys.
--   
--   <h2>Usage</h2>
--   
--   For issuers, import this module:
--   
--   <pre>
--   import SDJWT.Issuer
--   </pre>
--   
--   This gives you access to:
--   
--   <ul>
--   <li>Core data types (HashAlgorithm, SDJWT, SDJWTPayload, etc.)</li>
--   <li>Serialization functions (<a>serializeSDJWT</a>,
--   <a>deserializeSDJWT</a>)</li>
--   <li>Issuance functions (<a>createSDJWT</a>,
--   <a>createSDJWTWithDecoys</a>)</li>
--   <li>Helper functions (<a>addHolderKeyToClaims</a>)</li>
--   </ul>
--   
--   <h2>Creating SD-JWTs</h2>
--   
--   The main function for creating SD-JWTs is <a>createSDJWT</a>:
--   
--   <pre>
--   -- Create SD-JWT without typ or kid headers
--   result &lt;- createSDJWT Nothing Nothing SHA256 issuerKey ["given_name", "family_name"] claims
--   
--   -- Create SD-JWT with typ header (recommended)
--   result &lt;- createSDJWT (Just "sd-jwt") Nothing SHA256 issuerKey ["given_name", "family_name"] claims
--   
--   -- Create SD-JWT with typ and kid headers
--   result &lt;- createSDJWT (Just "sd-jwt") (Just "key-1") SHA256 issuerKey ["given_name"] claims
--   
--   -- Create SD-JWT with array elements (using JSON Pointer syntax)
--   result &lt;- createSDJWT Nothing Nothing SHA256 issuerKey ["nationalities/0", "nationalities/2"] claims
--   
--   -- Create SD-JWT with mixed object and array paths
--   result &lt;- createSDJWT Nothing Nothing SHA256 issuerKey ["address/street_address", "nationalities/1"] claims
--   </pre>
--   
--   <h2>Standard JWT Claims</h2>
--   
--   Standard JWT claims (RFC 7519) can be included in the <tt>claims</tt>
--   map and will be preserved in the issuer-signed JWT payload. During
--   verification, standard claims like <tt>exp</tt> (expiration time) and
--   <tt>nbf</tt> (not before) are automatically validated if present. See
--   RFC 9901 Section 4.1.
--   
--   <pre>
--   -- Create SD-JWT with expiration time
--   let expirationTime = currentTime + 3600  -- 1 hour from now
--   let claimsWithExp = Map.insert "exp" (Aeson.Number (fromIntegral expirationTime)) claims
--   result &lt;- createSDJWT (Just "sd-jwt") Nothing SHA256 issuerKey ["given_name"] claimsWithExp
--   </pre>
--   
--   <h2>JWT Headers</h2>
--   
--   Both <tt>typ</tt> and <tt>kid</tt> headers are supported natively
--   through jose's API:
--   
--   <ul>
--   <li><tt>typ</tt>: Recommended by RFC 9901 Section 9.11 for explicit
--   typing (e.g., "sd-jwt")</li>
--   <li><tt>kid</tt>: Key ID for key management (useful when rotating
--   keys)</li>
--   </ul>
--   
--   <h2>Decoy Digests</h2>
--   
--   To add decoy digests (to obscure the number of selectively disclosable
--   claims), use <a>createSDJWTWithDecoys</a>:
--   
--   <pre>
--   -- Create SD-JWT with 5 decoy digests, no typ or kid headers
--   result &lt;- createSDJWTWithDecoys Nothing Nothing SHA256 issuerKey ["given_name", "email"] claims 5
--   
--   -- Create SD-JWT with 5 decoy digests and typ header
--   result &lt;- createSDJWTWithDecoys (Just "sd-jwt") Nothing SHA256 issuerKey ["given_name", "email"] claims 5
--   
--   -- Create SD-JWT with 5 decoy digests, typ and kid headers
--   result &lt;- createSDJWTWithDecoys (Just "sd-jwt") (Just "key-1") SHA256 issuerKey ["given_name"] claims 5
--   </pre>
--   
--   For advanced use cases (e.g., adding decoys to nested <tt>_sd</tt>
--   arrays or custom placement logic), import SDJWT.Internal.Issuance to
--   access buildSDJWTPayload and other low-level functions.
--   
--   <h2>Key Binding Support</h2>
--   
--   To include the holder's public key in the SD-JWT (for key binding),
--   use <a>addHolderKeyToClaims</a> to add the <tt>cnf</tt> claim:
--   
--   <pre>
--   let holderPublicKeyJWK = "{"kty":"EC","crv":"P-256","x":"...","y":"..."}"
--   let claimsWithCnf = addHolderKeyToClaims holderPublicKeyJWK claims
--   result &lt;- createSDJWT (Just "sd-jwt") SHA256 issuerKey ["given_name"] claimsWithCnf
--   </pre>
--   
--   <h2>Example</h2>
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; import SDJWT.Issuer
--   
--   &gt;&gt;&gt; import qualified Data.Map.Strict as Map
--   
--   &gt;&gt;&gt; import qualified Data.Aeson as Aeson
--   
--   &gt;&gt;&gt; import qualified Data.Text as T
--   
--   &gt;&gt;&gt; let claims = Map.fromList [("sub", Aeson.String "user_123"), ("given_name", Aeson.String "John"), ("family_name", Aeson.String "Doe")]
--   
--   &gt;&gt;&gt; -- Note: In real usage, you would load your private key here
--   
--   &gt;&gt;&gt; -- issuerPrivateKeyJWK &lt;- loadPrivateKeyJWK
--   
--   &gt;&gt;&gt; -- result &lt;- createSDJWT Nothing SHA256 issuerPrivateKeyJWK ["given_name", "family_name"] claims
--   
--   &gt;&gt;&gt; -- case result of Right sdjwt -&gt; serializeSDJWT sdjwt; Left err -&gt; T.pack $ show err
--   </pre>
module SDJWT.Issuer

-- | Create a complete SD-JWT (signed).
--   
--   This function creates an SD-JWT and signs it using the issuer's key.
--   Creates a complete SD-JWT with signed JWT using jose.
--   
--   Returns the created SD-JWT or an error.
--   
--   <h2>Standard JWT Claims</h2>
--   
--   Standard JWT claims (RFC 7519) can be included in the <tt>claims</tt>
--   map and will be preserved in the issuer-signed JWT payload. During
--   verification, standard claims like <tt>exp</tt> and <tt>nbf</tt> are
--   automatically validated if present. See RFC 9901 Section 4.1 for
--   details.
--   
--   <h2>Example</h2>
--   
--   <pre>
--   -- Create SD-JWT without typ header
--   result &lt;- createSDJWT Nothing SHA256 issuerKey ["given_name", "family_name"] claims
--   
--   -- Create SD-JWT with typ header
--   result &lt;- createSDJWT (Just "sd-jwt") SHA256 issuerKey ["given_name", "family_name"] claims
--   
--   -- Create SD-JWT with expiration time
--   let claimsWithExp = Map.insert "exp" (Aeson.Number (fromIntegral expirationTime)) claims
--   result &lt;- createSDJWT (Just "sd-jwt") SHA256 issuerKey ["given_name"] claimsWithExp
--   </pre>
createSDJWT :: JWKLike jwk => Maybe Text -> Maybe Text -> HashAlgorithm -> jwk -> [Text] -> Object -> IO (Either SDJWTError SDJWT)

-- | Create an SD-JWT with optional typ header and decoy digests.
--   
--   This function is similar to <a>createSDJWT</a> but automatically adds
--   a specified number of decoy digests to the <tt>_sd</tt> array to
--   obscure the actual number of selectively disclosable claims.
--   
--   Returns the created SD-JWT or an error.
--   
--   <h2>Standard JWT Claims</h2>
--   
--   Standard JWT claims (RFC 7519) can be included in the <tt>claims</tt>
--   map and will be preserved in the issuer-signed JWT payload. During
--   verification, standard claims like <tt>exp</tt> and <tt>nbf</tt> are
--   automatically validated if present. See RFC 9901 Section 4.1 for
--   details.
--   
--   <h2>Example</h2>
--   
--   <pre>
--   -- Create SD-JWT with 5 decoy digests, no typ header
--   result &lt;- createSDJWTWithDecoys Nothing SHA256 issuerKey ["given_name", "email"] claims 5
--   
--   -- Create SD-JWT with 5 decoy digests and typ header
--   result &lt;- createSDJWTWithDecoys (Just "sd-jwt") SHA256 issuerKey ["given_name", "email"] claims 5
--   </pre>
createSDJWTWithDecoys :: JWKLike jwk => Maybe Text -> Maybe Text -> HashAlgorithm -> jwk -> [Text] -> Object -> Int -> IO (Either SDJWTError SDJWT)

-- | Add holder's public key to claims as a <tt>cnf</tt> claim (RFC 7800).
--   
--   This convenience function adds the holder's public key to the claims
--   map in the format required by RFC 7800 for key confirmation:
--   
--   <pre>
--   {
--     "cnf": {
--       "jwk": "<a>holderPublicKeyJWK</a>"
--     }
--   }
--   </pre>
--   
--   The <tt>cnf</tt> claim is used during key binding to prove that the
--   holder possesses the corresponding private key.
--   
--   <h2>Example</h2>
--   
--   <pre>
--   let holderPublicKeyJWK = "{"kty":"EC","crv":"P-256","x":"...","y":"..."}"
--   let claimsWithCnf = addHolderKeyToClaims holderPublicKeyJWK claims
--   result &lt;- createSDJWT (Just "sd-jwt") SHA256 issuerKey ["given_name"] claimsWithCnf
--   </pre>
--   
--   <h2>See Also</h2>
--   
--   <ul>
--   <li>RFC 7800: Proof-of-Possession Key Semantics for JSON Web Tokens
--   (JWT)</li>
--   <li>RFC 9901 Section 4.3: Key Binding</li>
--   </ul>
addHolderKeyToClaims :: Text -> Object -> Object


-- | Convenience module for SD-JWT verifiers.
--   
--   This module provides everything needed to verify SD-JWT presentations
--   and extract claims. It exports a focused API for the verifier role,
--   excluding modules that verifiers don't need (like Issuance and
--   Presentation).
--   
--   <h2>Usage</h2>
--   
--   For verifiers, import this module:
--   
--   <pre>
--   import SDJWT.Verifier
--   </pre>
--   
--   This gives you access to:
--   
--   <ul>
--   <li>Core data types (HashAlgorithm, SDJWTPresentation,
--   ProcessedSDJWTPayload, etc.)</li>
--   <li>Serialization functions (<a>deserializePresentation</a>)</li>
--   <li>Verification functions (<a>verifySDJWT</a>)</li>
--   </ul>
--   
--   <h2>Verifying SD-JWTs</h2>
--   
--   The main function for verifying SD-JWT presentations is
--   <a>verifySDJWT</a>:
--   
--   <pre>
--   -- Verify SD-JWT presentation (includes signature, disclosures, and key binding verification)
--   result &lt;- verifySDJWT issuerPublicKey presentation Nothing
--   case result of
--     Right processedPayload -&gt; do
--       let claims = processedClaims processedPayload
--       -- Use verified claims...
--       -- If key binding was present, access the holder's public key:
--       case keyBindingInfo processedPayload of
--         Just kbInfo -&gt; 
--           let holderPublicKey = kbPublicKey kbInfo
--           -- Use holder's public key for subsequent operations...
--         Nothing -&gt; -- No key binding present
--     Left err -&gt; -- Handle error
--   </pre>
--   
--   For advanced use cases (e.g., verifying key binding separately or
--   parsing payloads), import <a>Verification</a> to access additional
--   low-level functions.
--   
--   <h2>Example</h2>
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; import SDJWT.Verifier
--   
--   &gt;&gt;&gt; import qualified Data.Text as T
--   
--   &gt;&gt;&gt; -- Deserialize presentation received from holder
--   
--   &gt;&gt;&gt; -- let presentationText = "eyJhbGciOiJSUzI1NiJ9..."
--   
--   &gt;&gt;&gt; -- case deserializePresentation (T.pack presentationText) of
--   
--   &gt;&gt;&gt; --   Right presentation -&gt; do
--   
--   &gt;&gt;&gt; --     issuerPublicKeyJWK &lt;- loadPublicKeyJWK
--   
--   &gt;&gt;&gt; --     verifySDJWT issuerPublicKeyJWK presentation Nothing
--   
--   &gt;&gt;&gt; --   Left err -&gt; Left err
--   
--   &gt;&gt;&gt; -- Extract claims (includes both regular claims and disclosed claims)
--   
--   &gt;&gt;&gt; -- let claims = processedClaims processedPayload
--   </pre>
module SDJWT.Verifier

-- | Complete SD-JWT verification.
--   
--   This function performs all verification steps:
--   
--   <ol>
--   <li>Parses the presentation</li>
--   <li>Verifies issuer signature (required)</li>
--   <li>Validates standard JWT claims (if present): <tt>exp</tt>
--   (expiration time), <tt>nbf</tt> (not before), etc.</li>
--   <li>Extracts hash algorithm</li>
--   <li>Verifies disclosures match digests</li>
--   <li>Verifies key binding (if present)</li>
--   <li>Processes payload to reconstruct claims</li>
--   </ol>
--   
--   Returns the processed payload with all claims (both regular
--   non-selectively-disclosable claims and disclosed
--   selectively-disclosable claims). If a KB-JWT was present and verified,
--   the <a>keyBindingInfo</a> field will contain the holder's public key
--   extracted from the <tt>cnf</tt> claim, allowing the verifier to use it
--   for subsequent operations.
--   
--   <h2>Standard JWT Claims Validation</h2>
--   
--   Standard JWT claims (RFC 7519) included in the issuer-signed JWT are
--   automatically validated:
--   
--   <ul>
--   <li><tt>exp</tt> (expiration time): Token is rejected if expired</li>
--   <li><tt>nbf</tt> (not before): Token is rejected if not yet valid</li>
--   <li>Other standard claims are preserved but not validated by this
--   library</li>
--   </ul>
--   
--   For testing or debugging purposes where signature verification should
--   be skipped, use <a>verifySDJWTWithoutSignature</a> instead.
verifySDJWT :: JWKLike jwk => jwk -> SDJWTPresentation -> Maybe Text -> IO (Either SDJWTError ProcessedSDJWTPayload)


-- | This module re-exports the persona-specific modules for convenient
--   access. Most users should import the specific persona module they need
--   instead.
--   
--   <h2>Recommended Usage</h2>
--   
--   Import the persona-specific module for your role:
--   
--   <pre>
--   import SDJWT.Issuer   -- For creating and issuing SD-JWTs
--   import SDJWT.Holder   -- For receiving SD-JWTs and creating presentations
--   import SDJWT.Verifier -- For verifying SD-JWT presentations
--   </pre>
--   
--   <h2>Advanced Usage</h2>
--   
--   For library developers or advanced users who need low-level access,
--   import specific Internal modules as needed:
--   
--   <pre>
--   import SDJWT.Internal.Types
--   import SDJWT.Internal.Serialization
--   import SDJWT.Internal.Issuance
--   -- etc.
--   </pre>
module SDJWT
